// Codeforces Round #167
// Problem E -- Dima and Game
#include <cstdio>
#include <cstring>
#include <climits>
#include <algorithm>

const int MOD = 1000000000 + 7;

const int STARTS[102][2] = {{1, 0}, {3, 1}, {4, 2}, {5, 1}, {7, 2}, {9, 0}, {13, 1}, {15, 2}, {19, 0}, {27, 1}, {39, 2}, {40, 0}, {57, 2}, {58, 1}, {81, 2}, {85, 0}, {120, 2}, {121, 1}, {174, 2}, {179, 0}, {255, 2}, {260, 1}, {363, 2}, {382, 0}, {537, 2}, {544, 1}, {780, 2}, {805, 0}, {1146, 2}, {1169, 1}, {1632, 2}, {1718, 0}, {2415, 2}, {2447, 1}, {3507, 2}, {3622, 0}, {5154, 2}, {5260, 1}, {7341, 2}, {7730, 0}, {10866, 2}, {11011, 1}, {15780, 2}, {16298, 0}, {23190, 2}, {23669, 1}, {33033, 2}, {34784, 0}, {48894, 2}, {49549, 1}, {71007, 2}, {73340, 0}, {104352, 2}, {106510, 1}, {148647, 2}, {156527, 0}, {220020, 2}, {222970, 1}, {319530, 2}, {330029, 0}, {469581, 2}, {479294, 1}, {668910, 2}, {704371, 0}, {990087, 2}, {1003364, 1}, {1437882, 2}, {1485130, 0}, {2113113, 2}, {2156822, 1}, {3010092, 2}, {3169669, 0}, {4455390, 2}, {4515137, 1}, {6470466, 2}, {6683084, 0}, {9509007, 2}, {9705698, 1}, {13545411, 2}, {14263510, 0}, {20049252, 2}, {20318116, 1}, {29117094, 2}, {30073877, 0}, {42790530, 2}, {43675640, 1}, {60954348, 2}, {64185794, 0}, {90221631, 2}, {91431521, 1}, {131026920, 2}, {135332446, 0}, {192557382, 2}, {196540379, 1}, {274294563, 2}, {288836072, 0}, {405997338, 2}, {411441844, 1}, {589621137, 2}, {608996006, 0}, {866508216, 2}, {884431705, 1}};

int n, p, count[3], ways[2][4];

int main() {
    scanf("%d%d", &n, &p);
    memset(count, 0, sizeof(count));
    for (int i = 0; i < 102 && STARTS[i][0] < p; ++ i) {
        int begin = STARTS[i][0];
        int end = std::min(i + 1 < 102 ? STARTS[i + 1][0] : INT_MAX, p);
        (count[STARTS[i][1]] += (long long)(p - begin + p - (end - 1)) * (end - begin) / 2 % MOD) %= MOD;
    }
    memset(ways, 0, sizeof(ways));
    ways[0][0] = 1;
    for (int i = 0; i < n; ++ i) {
        memset(ways[i + 1 & 1], 0, sizeof(ways[i + 1 & 1]));
        for (int j = 0; j < 4; ++ j) {
            for (int k = 0; k < 3; ++ k) {
                (ways[i + 1 & 1][j ^ k] += (long long)ways[i & 1][j] * count[k] % MOD) %= MOD;
            }
        }
    }
    printf("%d\n", ((ways[n & 1][1] + ways[n & 1][2]) % MOD + ways[n & 1][3]) % MOD);
    return 0;
}
